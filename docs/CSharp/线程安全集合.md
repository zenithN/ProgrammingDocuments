# 线程安全集合

> 命名空间:System.Collections.Concurrent 

1. `ConcurrentBag<T>` 表示对象的线程安全无序集合。
2. `ConcurrentDictionary<TKey,TValue>` 表示可同时由多个线程访问的键/值对的线程安全集合。
3. `ConcurrentQueue<T>` 表示线程安全的先出 （FIFO） 集合。
4. `ConcurrentStack<T>` 表示线程安全最后一次传入 （LIFO） 集合。
5. `BlockingCollection<T>` 一个线程安全的集合，内部使用其他线程安全集合（如 ConcurrentQueue）作为基础数据结构，并且提供了**阻塞的添加和移除**操作。


都实现了接口 `IProducerConsumerCollection<T>`

[**官网参考链接**](https://learn.microsoft.com/zh-cn/dotnet/standard/collections/thread-safe/blockingcollection-overview)

## `BlockingCollection<T>`
提供功能：
- 实现制造者-使用者模式。
- 通过多线程并发添加和获取项。
- 可选最大容量。
- 集合为空或已满时通过插入和移除操作进行阻塞。
- 插入和移除“尝试”操作不发生阻塞，或在指定时间段内发生阻塞
- 封装实现 IProducerConsumerCollection<T> 的任何集合类型
- 使用取消标记执行取消操作。
- 支持使用 foreach的两种枚举。
  - 只读枚举。
  - 在枚举项时将项移除的枚举。

**制造线程可调用 CompleteAdding 来指示不再添加项。**

**使用者将监视 IsCompleted 属性以了解集合何时为空且不再添加项。**



```C#
BlockingCollection<int> collection = new BlockingCollection<int>(boundedCapacity: 10);

// 添加元素（如果达到容量上限，将会阻塞直到有空间）
collection.Add(1);

// 取出元素（如果集合为空，将会阻塞直到有元素可用）
int item = collection.Take();

```

# Partitioner 

Partitioner 是 .NET 中一个非常有用的工具，用于将大数据集划分为多个小块，以便在并行处理中提高性能。它通常与 Parallel.ForEach 或 PLINQ 一起使用，能够动态分配任务，确保多个线程能够高效工作。

## 为什么使用 Partitioner
在多线程编程中，如果数据直接按固定大小划分，可能会导致一些线程工作完后闲置，而其他线程仍在工作。使用 Partitioner，可以更智能地将数据动态划分给多个线程，使负载更加均衡，确保最大限度地利用 CPU 资源。

## Partitioner 的基本用法

1. **简单的静态分区**

    最简单的方式是将一组数据划分为固定数量的区块，然后交给多个线程处理。我们可以使用 Partitioner.Create() 方法创建一个分区器，然后将其传递给 Parallel.ForEach。

    ```C#
    using System;
    using System.Collections.Concurrent;
    using System.Threading.Tasks;

    class Program
    {
        static void Main()
        {
            // 创建分区器，将 [0, 100) 范围划分为多个区间
            var rangePartitioner = Partitioner.Create(0, 100);

            // 使用并行处理区间
            Parallel.ForEach(rangePartitioner, (range, loopState) =>
            {
                for (int i = range.Item1; i < range.Item2; i++)
                {
                    Console.WriteLine($"Processing item {i} on thread {Task.CurrentId}");
                }
            });
        }
    }

    ```
    在这个示例中，Partitioner.Create(0, 100) 创建了一个分区器，它将范围 [0, 100) 划分为多个小区间。Parallel.ForEach 方法会并行处理这些区间，每个区间由不同的线程处理。

2. **动态分区**
   
    静态分区在某些情况下可能效率不高，特别是当不同任务的处理时间差异很大时，一些线程可能会比其他线程更早完成任务。为了解决这个问题，可以使用动态分区来平衡工作负载。

    动态分区器能够根据执行情况动态划分数据，让线程在空闲时继续处理剩余的数据，确保所有线程都能得到足够的工作。

    ```C#
    using System;
    using System.Collections.Concurrent;
    using System.Threading.Tasks;

    class Program
    {
        static void Main()
        {
            // 创建带有动态负载均衡的分区器
            var rangePartitioner = Partitioner.Create(0, 100, loadBalance: true);

            Parallel.ForEach(rangePartitioner, (range, loopState) =>
            {
                for (int i = range.Item1; i < range.Item2; i++)
                {
                    Console.WriteLine($"Processing item {i} on thread {Task.CurrentId}");
                }
            });
        }
    }
    ```
    这里的 Partitioner.Create(0, 100, loadBalance: true) 启用了动态负载均衡。当某个线程完成任务时，系统会为它分配新的数据块继续处理。

3. **处理有序数据**:OrderablePartitioner<T>

    如果数据集合有序，并且希望在并行处理中保持数据的顺序，可以使用 OrderablePartitioner<T>。它确保分区器在并行处理时，保留集合的顺序。

    ```C#
    using System;
    using System.Collections.Concurrent;
    using System.Linq;
    using System.Threading.Tasks;

    class Program
    {
        static void Main()
        {
            var data = Enumerable.Range(0, 100).ToArray();

            // 创建有序的分区器
            var orderablePartitioner = Partitioner.Create(data, EnumerablePartitionerOptions.NoBuffering);

            Parallel.ForEach(orderablePartitioner, (item, loopState, index) =>
            {
                Console.WriteLine($"Processing item {item} at index {index} on thread {Task.CurrentId}");
            });
        }
    }
    ```
    在这个例子中，OrderablePartitioner 会确保按照 data 的顺序处理每个元素，并且为每个元素提供相应的索引。

## 自定义 Partitioner

> 可以通过继承 Partitioner<T> 来创建自己的分区器。这种情况下，你可以完全自定义如何划分数据，并且控制线程如何消费这些数据。

自定义实现
```C#
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

public class MyCustomPartitioner : Partitioner<int>
{
    private readonly IList<int> _data;

    public MyCustomPartitioner(IList<int> data)
    {
        _data = data;
    }

    public override bool SupportsDynamicPartitions => true;

    public override IList<IEnumerator<int>> GetPartitions(int partitionCount)
    {
        var partitions = new List<IEnumerator<int>>(partitionCount);
        int size = _data.Count / partitionCount;

        for (int i = 0; i < partitionCount; i++)
        {
            int start = i * size;
            int end = (i == partitionCount - 1) ? _data.Count : start + size;

            partitions.Add(GetRangeEnumerator(start, end));
        }

        return partitions;
    }

    private IEnumerator<int> GetRangeEnumerator(int start, int end)
    {
        for (int i = start; i < end; i++)
        {
            yield return _data[i];
        }
    }
}
```

自定义的 Partitioner 可以根据数据的大小来划分区块，并返回多个 IEnumerator<int>，供并行操作使用。在这个例子中，分区器会将数据集合分割为若干个区块，每个区块对应一段连续的数据。

## Partitioner 的常见用法

与 Parallel.ForEach 结合，来处理大规模数据的并行处理。

```C#
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        var data = new int[10000];

        // 初始化数据
        for (int i = 0; i < data.Length; i++)
        {
            data[i] = i;
        }

        // 创建一个分区器
        var partitioner = Partitioner.Create(data, EnumerablePartitionerOptions.NoBuffering);

        // 使用并行处理分区数据
        Parallel.ForEach(partitioner, (item) =>
        {
            // 对数据执行操作
            Process(item);
        });
    }

    static void Process(int item)
    {
        // 模拟一些工作
        Console.WriteLine($"Processing item {item} on thread {Task.CurrentId}");
    }
}
```
## EnumerablePartitionerOptions 枚举

NoBuffering

1

**创建分区程序**，该程序从源可枚举项中一次提取项而不使用中间存储，多个线程可以更有效地访问该存储。 此选项支持低延迟（一从源获得项目就对其进行处理）且部分支持项目间的依赖项（线程无法死锁等待线程自身负责处理的项目）。

None

0	

使用默认行为，就是使用缓冲实现最佳性能。
